<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .wrapper{
            width: 500px;
            height: 500px;
            margin: 100px auto;
            border: 1px solid #000;
        }
        .content{
            width: 50%;
            height: 50%;
            padding-top:50%;
            border: 1px solid #000;
            position: relative;
        }
        .box{
            width: 100%;
            height:50%;
            position: absolute;
            left: 0;
            top:0;
            background-color: red;
        }
    </style>
</head>

<body>
    <div class="wrapper">
        <div class="content">
            <div class="box">

            </div>
        </div>
    </div>
    <!-- <div class="wrapper">
        <div class="content">
            <div class="box">
                <strong></strong>
                <span></span>
                <p></p>
                <i></i>
                <i></i>
                <p></p>
                <span></span>
                <strong></strong>
            </div>
        </div>
    </div> -->
    <script>
        //         1.写一个方法，求一个字符串的长度； str.charCodeAt()可以求出指定的Unicode编码
        //         编码>255时为中文，中文占两个字节；编码<255为英文，英文占一个字节
        //    var codeFunc = (function(){
        //        return function(str){
        //            var codeLen = 0;
        //             for(var i =0; i<str.length; i++){
        //                 if(str[i].charCodeAt()>255){
        //                       codeLen +=2;
        //                 }else{
        //                     codeLen +=1;
        //                 }
        //             }
        //             return codeLen;
        //        }
        //    }());
        //  console.log(codeFunc('你好')) ;

        //         2.使用call、apply方法
        //    var name = 'sds';
        //    function demo(hwt,age,height){
        // console.log(hwt);
        // console.log(age);
        // console.log(height);
        // console.log(arguments[0])
        //    var name = 'deng';
        //    console.log(age);
        //    console.log(height);
        //    console.log(this.age);
        //    console.log(this.name);
        //    }
        //    var obj = {
        //        name:'hwt',
        //        age:18,
        //    }
        //    demo.call();
        //    demo();
        //    new demo();
        // demo.apply(obj,['hwthwt',20,187])




        //3.圣杯模式继承
        // Father.prototype.name = "hwt";
        // function Father(){
        //     this.age = 12;
        //     this.height = 185;
        // }

        // function Son(){

        // }
        // function inheirt(target,origin){
        //     function F(){};
        //     F.prototype = origin.prototype;
        //     target.prototype = new F();
        //     target.prototype.constructor = target;
        // }
        // inheirt(Son,Father);
        // var father = new Father();
        // var son = new Son();
        // Son.prototype.sex = 'male';



        //         4.深度克隆

        // var obj = {
        //     name: 'hwt',
        //     age: 20,
        //     skills: {
        //         sing: 'song',
        //         eat: ['fish', 'meat'],
        //     }
        // }
        // var newObj = {
        //     name: 'he',
        // };

        // function deepClone(target, origin) {
        //     var target = target || {};
        //     var str = Object.prototype.toString;
        //     for (var prop in origin) {
        //         if (origin.hasOwnProperty(prop)) {
        //             if (origin[prop] != null && typeof (origin[prop]) == 'object') {
        //                 if (str.call(origin[prop]) == '[object Array]') {
        //                     target[prop] = [];
        //                 } else {
        //                     target[prop] = {};
        //                 }
        //                 deepClone(target[prop], origin[prop]);
        //             } else {
        //                 target[prop] = origin[prop];
        //             }
        //         }
        //     }
        // }
        // deepClone(newObj, obj);

        // newObj.skills.sing = "jump";
        // newObj.skills.eat.push('apple');


        //         6.实现对一个数组进行乱序

        // var arr = [1,2,3,4,5,6];

        // arr.sort(function(a,b){
        //     return Math.random() - 0.5;
        // });


        //         7.封装typeof方法,可以对原始值，引用值等完美的进行处理


        //         8.！！解决数组去重问题

        // var arr = [2,2,5,6,5,1,2,3];
        // Array.prototype.unique = function(){
        //     var obj = { };
        //     var newArr = [];
        //     for(var i = 0 ;i<this.length;i++){
        //         if(!obj[arr[i]]){
        //             obj[arr[i]] = 'abc';
        //             newArr.push(arr[i]);
        //         }
        //     }
        //     return newArr;
        // }
        // var os = new Set(arr);


        //           }
        //(3).一个字符串[a-z]组成，请找出该字符串出现的第一只出现一次的字母
        // var str = 'asdadsadasdgfgvcv';
        // var obj = {};
        // var arr = [];
        // var temp = 0;
        // for(var i = 0 ; i<str.length ; i++){
        //    for(var j = 0; j<str.length; j++){
        //         if(str[i] == str[j]){
        //             temp++;
        //         }
        //         if(j == str.length - 1){
        //              if(temp == 1){
        //                 arr.push(str[i]);
        //              }
        //              temp = 0;
        //         }
        //    }
        // }
        // console.log(arr[0]);




        //         9.把div下面所有的直接子元素点挑出来吗，放在数组里，不能用children

        // var odiv = document.getElementsByTagName('div')[0];
        // var ochild = odiv.childNodes;
        // var arr = [];
        // for(var i = 0 ;i<ochild.length;i++){
        //     console.log(ochild[i].nodeType)
        //     if(ochild[i].nodeType == 1){
        //         arr.push(ochild[i]);
        //     }
        // }
        // console.log(arr);



        //         10.封装函数，返回元素e的第n层祖先元素
        // var op = document.getElementsByTagName('p')[0];
        // function getParents(ele,n){
        //     if(n){
        //         while(n>0 && ele){
        //             ele = ele.parentElement;
        //             if(!ele){
        //                 return '不存在';
        //             }
        //             n--;
        //         }
        //     }
        //     return ele;
        // }
        // getParents(op,3);



        //         11.封装函数，返回元素e的第n个兄弟节点，n为正,返回后面的兄弟节点;n为负，返回前面的兄弟节点；n为0，返回自己
        //         方法1，兼容性可能有问题
                //    var op = document.getElementsByTagName('p')[0];
                //    function getSibling(ele,n){
                //      if(n == 0){
                //         return ele;
                //      }
                //      if(n>0){
                //          while(n>0 && ele){
                //              ele = ele.nextElementSibling;
                //              n--;
                //          }
                //      }else{
                //         while(n<0 &&ele){
                //             ele = ele.previousElementSibling;
                //             n++;
                //        }
                //      }
                //      return ele;
                //    }
                //    getSibling(op,0)


        //         12.编辑函数，封装函数children功能，解决以前部分浏览器兼容性问题
                //   var obox = document.getElementsByClassName('box')[0];
                //   var ochild = obox.childNodes;
                //   var arr = [];
                //   for(var i =0 ; i<ochild.length ;i++){
                //       if(ochild[i].nodeType == 1){
                //          arr.push(ochild[i]);
                //       }
                //   }



        //         13.自己封装hasChildren()方法，不可用children;



        //         14.封装函数insertAfter(a,b);插入a在标签b之后;功能类似于insertBefore();
                    // var op = document.getElementsByTagName('p') [0];
                    // var ostrong = document.getElementsByTagName('strong')[0];
                    // var obox = document.getElementsByClassName('box')[0];

                    // Element.prototype.insertAfter = function(a,b){
                    //     // var par = a.parentElement;
                    //     // console.log(par);
                    //     this.insertBefore(b,a);
                    // }
                   
                    // Element.prototype.insertAfter = function(a,b){
                    //     var nextNodes = b.nextElementSibling;
                    //     if(nextNodes == null){
                    //         this.appendChild(a);
                    //     }else{
                    //         this.insertBefore(a,nextNodes);
                    //     }
                    // }
                    //  obox.insertAfter(op,ostrong);
                    

        //         15.内部标签逆序
                    // var obox = document.getElementsByClassName('box')[0];
                    // var child = obox.children;
                    // for(var i = child.length - 2; i>=0 ;i--){
                    //     obox.appendChild(child[i]);
                    // }


        //         16.封装remove(),使孩子自己可以销毁自己 --->借助父类的方法自己销毁自己


        //         17.封装函数，打印当前是何年何月何日何时几分几秒



        //         18.封装兼容性方法(哪个浏览器都好用)，求滚动距离getScrollOffset();
                      


        //         19.封装查看可视窗口的兼容性方法


        //         20.封装兼容性方法，进行css属性查询,顺带对伪元素的属性值进行查询

        //         方法2.利用事件的委托解决li访问的问题 --->这个方法更好！！！


        //         22.封装兼容性的事件绑定方法addEvent


        //         23.封装取消冒泡的函数stopBubble();

        //         24.封装阻止默认事件的函数cancelHandler(e);


        //         26.封装兼容性的byClassName



        //27.


        //28.模仿懒加载



        //1. 字符串反转
        // var str = '123abc';







        //2.二分查找数组的索引
        //  var arr =[1,3,4,5,6,7,8,10,21];
        //  //0 1 2 3 4 5 6 7 8
        




        //3.  对称数组 [a,b,c,b,a]  [a,b,c,c,b,a];

        // var arr = ['a','b','d','c','b','a'];
        // var arr1 =['x','b','c','b','x'];




        // 查询子串首次出现的位置,abcbcxyxyz  字串为bc  结果为1



        // 5. 计算数组中,最大连续增长序列的长度,[1,2,3,4,1,2,3,4,5,1,2,3] 结果为5


        // Ajax    
    </script>
</body>

</html>